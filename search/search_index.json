{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"build_tooling/cmake/","title":"CMake Kullan\u0131m","text":"<p>CMake, yaz\u0131l\u0131m projelerinin derleme s\u00fcrecini y\u00f6neten, farkl\u0131 derleyiciler ve i\u015fletim sistemleri aras\u0131nda uyumluluk sa\u011flayan g\u00fc\u00e7l\u00fc bir ara\u00e7t\u0131r. Projelerin derleme se\u00e7eneklerini, ba\u011f\u0131ml\u0131l\u0131klar\u0131n\u0131 tan\u0131mlayarak yap\u0131land\u0131rma i\u015flemlerini otomatikle\u015ftirir.</p>"},{"location":"build_tooling/cmake/#temel-komutlar","title":"Temel Komutlar","text":"<pre><code>cmake --help                     # CMake ve build y\u00f6ntemleri hakk\u0131nda genel bilgi.\ncmake --help-variable-list       # Kullan\u0131labilir de\u011fi\u015fkenleri listeler.\ncmake --help-variable [variable] # Belirtilen de\u011fi\u015fken hakk\u0131nda detayl\u0131 bilgi.\n\n# Genel kullan\u0131m:\ncmake -G \"Ninja\" -DCMAKE_BUILD_TYPE=Release -S . -B build\ncmake -P CMakeLists.txt  # Build i\u015flemi yapmadan CMake dosyas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\u0131r.\n</code></pre>"},{"location":"build_tooling/cmake/#projeyi-derleme-yontemleri","title":"Projeyi Derleme Y\u00f6ntemleri","text":"Y\u00f6ntem 1Y\u00f6ntem 2Y\u00f6ntem 3 <pre><code>mkdir build  \ncd build  \ncmake ..  \nmake\n</code></pre> <pre><code>cmake -S . -B build  \ncd build  \nmake \n</code></pre> <pre><code>cmake -B build  \ncmake --build build\n</code></pre>"},{"location":"build_tooling/cmake/#cmake-dosya-yaps","title":"CMake Dosya Yap\u0131s\u0131","text":"<ul> <li> <p>CMakeLists.txt ana dizinlerde kullan\u0131l\u0131r.</p> </li> <li> <p><code>.cmake</code> uzant\u0131l\u0131 dosyalar script veya mod\u00fcl olarak kullan\u0131l\u0131r:</p> <ul> <li>Directories (CMakeLists.txt)</li> <li>Scripts (<code>&lt;script&gt;.cmake</code>)</li> <li>Modules (<code>&lt;module&gt;.cmake</code>)</li> </ul> </li> <li><code>if - elseif - else</code>: Mant\u0131ksal i\u015flemler.</li> <li><code>foreach</code> ve <code>while</code> d\u00f6ng\u00fcleri: Yinelemeli i\u015flemler i\u00e7in.</li> <li><code>function</code>: Lokal kapsam.</li> <li><code>macro</code>: Global kapsam.</li> </ul>"},{"location":"build_tooling/cmake/#degiskenler","title":"De\u011fi\u015fkenler","text":"De\u011fi\u015fken Anlam\u0131 <code>PROJECT_NAME</code> project() komutunda belirtilen proje ad\u0131 <code>CMAKE_PROJECT_NAME</code> En \u00fcst dizindeki project() ad\u0131 <code>CMAKE_VERSION</code> CMake s\u00fcr\u00fcm\u00fc (\u00f6rn: 3.16.1) <code>CMAKE_GENERATOR</code> Yap\u0131 olu\u015fturucuyu belirtir (Ninja, Unix Makefiles) <code>CMAKE_SOURCE_DIR</code> Ana proje dizini <code>CMAKE_CURRENT_SOURCE_DIR</code> Bulunulan dizin <code>PROJECT_SOURCE_DIR</code> En son \u00e7a\u011fr\u0131lan project() dizini <code>CMAKE_BINARY_DIR</code> Build dizini <code>CMAKE_HOME_DIRECTORY</code> En \u00fcst dizin yolu <code>CMAKE_SYSTEM</code> \u0130\u015fletim sisteminin tam ad\u0131 <code>CMAKE_SYSTEM_NAME</code> \u0130\u015fletim sistemi ad\u0131 (Linux, Windows) <code>CMAKE_INSTALL_PREFIX</code> Kurulum dizini <code>CMAKE_MODULE_PATH</code> Ek CMake mod\u00fcllerinin yolu"},{"location":"build_tooling/cmake/#temel-komutlar-ve-kullanmlar","title":"Temel Komutlar ve Kullan\u0131mlar\u0131","text":"<ul> <li><code>cmake_minimum_required</code>: Kullan\u0131lmas\u0131 gereken minimum CMake s\u00fcr\u00fcm\u00fcn\u00fc belirtir.</li> <li><code>project</code>: Projeyi isimlendirir, kullan\u0131lacak dilleri ve versiyonlar\u0131 belirtir.</li> <li><code>add_executable</code>: Y\u00fcr\u00fct\u00fclebilir dosya olu\u015fturur.</li> <li><code>add_library</code>: K\u00fct\u00fcphane hedefleri olu\u015fturur.</li> <li><code>add_subdirectory</code>: Alt dizindeki CMake dosyas\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\u0131r.</li> <li><code>target_include_directories</code>: Hedefe \u00f6zel header dizinlerini tan\u0131mlar.<ul> <li>PUBLIC: Hem hedef hem t\u00fcketiciler</li> <li>PRIVATE: Sadece hedef</li> <li>INTERFACE: Sadece t\u00fcketiciler</li> </ul> </li> <li><code>install</code>: Dosyalar\u0131n belirli dizinlere kurulmas\u0131n\u0131 sa\u011flar</li> <li><code>find_package</code>: CMake mod\u00fcllerini bulur ve kullan\u0131ma haz\u0131rlar.</li> <li><code>add_definitions</code>: Derleme zaman\u0131 tan\u0131mlar ekler.</li> <li><code>option</code>: Derleme se\u00e7enekleri sunar.</li> <li><code>add_compile_options</code>: Derleyici parametreleri ekler.</li> <li><code>file(GLOB)</code> ve <code>file(GLOB_RECURSE)</code>: Dosya listeleri olu\u015fturur.</li> <li><code>execute_process</code>: Terminal komutlar\u0131n\u0131 \u00e7al\u0131\u015ft\u0131r\u0131r.</li> <li><code>set_property</code>: Nesnelere \u00f6zellik atar.</li> <li><code>set_target_properties</code>: Hedef \u00f6zelliklerini belirler.</li> <li><code>cmake_policy</code>: Uyumluluk davran\u0131\u015flar\u0131n\u0131 y\u00f6netir.</li> <li><code>add_custom_command</code> ve add_custom_target: \u00d6zel build komutlar\u0131 olu\u015fturur.</li> </ul> <pre><code>cmake_minimum_required(VERSION 3.10)\nproject(myProject LANGUAGES C CXX VERSION 1.0)\n\nfind_package(my_log CONFIG REQUIRED)\n\noption(ENABLE_FEATURE \"Enable feature X\" OFF)\n\nfile(GLOB_RECURSE SRC_FILES ${PROJECT_SOURCE_DIR}/src/*.cpp)\nexecute_process(COMMAND git pull WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})\n\ninclude_directories(${PROJECT_SOURCE_DIR}/inc)\nadd_library(my_add add.cpp)\nadd_executable(my_project main.cpp)\ntarget_link_libraries(my_project PRIVATE my_add)\nadd_subdirectory(add_dir)\n\nset_target_properties(myTarget PROPERTIES COMPILE_FLAGS \"-O3 -Wall\")\n\ntarget_include_directories(my_add PUBLIC ${PROJECT_SOURCE_DIR}/inc)\n\ninstall(FILES include/log.hpp DESTINATION include)\ninstall(TARGETS myLib EXPORT my_export DESTINATION lib)\n</code></pre> <p>Not</p> <p>Cache De\u011fi\u015fkenleri, belle\u011fe al\u0131nan de\u011fi\u015fkenler, tekrar hesaplanmay\u0131 \u00f6nler ve h\u0131zl\u0131 eri\u015fim sa\u011flar. <pre><code>set(VAR \"12\" CACHE STRING \"A\u00e7\u0131klama\")\n</code></pre></p> <p>Bu rehber, CMake'in temel ve geli\u015fmi\u015f \u00f6zelliklerini tan\u0131tmakta olup, projelerinizi etkili \u015fekilde y\u00f6netmeniz i\u00e7in gerekli bilgileri sunar.</p>"},{"location":"build_tooling/compiler/","title":"Derleyici Se\u00e7enekleri ve Derleme S\u00fcreci","text":"<p>Bu d\u00f6k\u00fcmantasyon, GCC ve G++ derleyicilerinin temel kullan\u0131m\u0131n\u0131, VS Code ayarlar\u0131n\u0131 ve C/C++ derleme s\u00fcrecinin ad\u0131mlar\u0131n\u0131 a\u00e7\u0131klar.</p>"},{"location":"build_tooling/compiler/#gcc-gnu-compiler-collection","title":"GCC (GNU Compiler Collection)","text":"<pre><code>gcc -o main.o main.c -Wall -Wextra -Wconversion -Wsign-conversion\n</code></pre> <ul> <li> <p>Wall: Temel uyar\u0131lar\u0131n tamam\u0131n\u0131 aktif eder.</p> </li> <li> <p>Wextra: Daha fazla (detayl\u0131) uyar\u0131 mesaj\u0131 g\u00f6sterir.</p> </li> <li> <p>Wconversion: T\u00fcr d\u00f6n\u00fc\u015f\u00fcmleriyle ilgili uyar\u0131lar\u0131 g\u00f6sterir.</p> </li> <li> <p>Wsign-conversion: \u0130\u015faretli (signed) ve i\u015faretsiz (unsigned) t\u00fcrler aras\u0131ndaki d\u00f6n\u00fc\u015f\u00fcmlerde uyar\u0131 verir.</p> </li> </ul>"},{"location":"build_tooling/compiler/#g-gnu-c-compiler","title":"G++ (GNU C++ Compiler)","text":"<pre><code>g++ -o main.o main.cpp -std=c++11 -I/source/includes\n</code></pre> <ul> <li> <p>std=c++11: Derleme s\u0131ras\u0131nda C++11 standard\u0131 kullan\u0131l\u0131r.</p> </li> <li> <p>I: Ba\u015fl\u0131k dosyalar\u0131n\u0131n bulundu\u011fu dizin belirtilir (include path).</p> </li> </ul>"},{"location":"build_tooling/compiler/#vs-code-derleyici-ayarlar","title":"VS Code Derleyici Ayarlar\u0131","text":"tasks.json<pre><code>{\n  \"version\": \"2.0.0\",\n  \"tasks\": [\n    {\n      \"label\": \"C++ Build\",\n      \"type\": \"shell\",\n      \"command\": \"g++\",\n      \"args\": [\n        \"-std=c++20\",\n        \"-Wall\",\n        \"-Wextra\",\n        \"-Wconversion\",\n        \"-Wsign-conversion\",\n        \"-Werror\",\n        \"-o\", \"main\",\n        \"main.cpp\"\n      ],\n      \"group\": {\n        \"kind\": \"build\",\n        \"isDefault\": true\n      }\n    }\n  ]\n}\n</code></pre>"},{"location":"build_tooling/compiler/#derleme-sureci","title":"Derleme S\u00fcreci","text":"<p>Derleme s\u00fcreci 4 temel ad\u0131mdan olu\u015fur:</p> <pre><code>graph LR\n  A[main.c] --&gt; |Preprocessor| B{main.i};\n  B --&gt; |Compiler| C[main.s];\n  C --&gt; |Assembler| D[main.s];\n  D --&gt; |Assembler| E[main.o];\n  E --&gt; |Linker| F[main];</code></pre> <p>1\ufe0f\u20e3 Preprocessor (\u00d6n \u0130\u015flemci): Yorum sat\u0131rlar\u0131 kald\u0131r\u0131l\u0131r, <code>#define</code> ve <code>#include</code> gibi direktifler i\u015flenir.</p> <pre><code>gcc -E main.c -o main.i\n</code></pre> <p>2\ufe0f\u20e3 Compiler (Derleyici): Kod, assembly diline \u00e7evrilir (donan\u0131ma daha yak\u0131n bir dil).</p> <pre><code>gcc -S main.i -o main.s\n</code></pre> <p>3\ufe0f\u20e3 Assembler (\u00c7evirici): Assembly kodu makine koduna d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr (binary).</p> <pre><code>gcc -c main.s -o main.o\n</code></pre> <p>4\ufe0f\u20e3 Linker (Ba\u011flay\u0131c\u0131): Object dosyalar birle\u015ftirilerek \u00e7al\u0131\u015ft\u0131r\u0131labilir program \u00fcretilir.</p> <pre><code>gcc main.o -o main\n</code></pre> <p>Not</p> <p>T\u00fcm bu ad\u0131mlar\u0131 tek komutla ger\u00e7ekle\u015ftirmek ve ara dosyalar\u0131 (.i, .s, .o) da g\u00f6rmek isterseniz: <pre><code>gcc -save-temps main.c -o main\n</code></pre> Bu komut, derleme s\u0131ras\u0131nda olu\u015fturulan t\u00fcm ge\u00e7ici dosyalar\u0131 da kaydeder.</p>"},{"location":"build_tooling/make/","title":"Make ve Makefile Kullan\u0131m\u0131","text":"<p>Make, yaz\u0131l\u0131m projelerinde kaynak kodlar\u0131n derlenmesi ve yap\u0131 ad\u0131mlar\u0131n\u0131n otomatikle\u015ftirilmesi i\u00e7in kullan\u0131lan g\u00fc\u00e7l\u00fc bir ara\u00e7t\u0131r. \u00d6zellikle b\u00fcy\u00fck projelerde zamandan tasarruf sa\u011flar ve yap\u0131 s\u00fcrecini standardize eder.</p> <p>Not</p> <p>Makefile\u2019da girintiler TAB karakteriyle yap\u0131lmal\u0131d\u0131r. Bo\u015fluk (space) kullanmak hata ile sonu\u00e7lan\u0131r!</p>"},{"location":"build_tooling/make/#temel-sozdizimi-ve-semboller","title":"Temel S\u00f6zdizimi ve Semboller","text":"Sembol Anlam\u0131 <code>#</code> Yorum sat\u0131r\u0131. Sat\u0131r\u0131n en ba\u015f\u0131nda kullan\u0131lmal\u0131d\u0131r. <code>\\</code> Sat\u0131r\u0131 bir sonrakine ta\u015f\u0131mak i\u00e7in kullan\u0131l\u0131r (sat\u0131r devam\u0131). <code>@</code> Komutun \u00e7\u0131kt\u0131s\u0131 ekrana yaz\u0131lmaz. <code>make -s</code> ile ayn\u0131 etki yarat\u0131r. <code>:</code> Bir hedef (target) tan\u0131mlar. <code>::</code> Ayn\u0131 isme sahip birden fazla hedef tan\u0131m\u0131na izin verir. <code>$</code> De\u011fi\u015fken referanslar\u0131nda kullan\u0131l\u0131r. <code>=</code> Normal de\u011fi\u015fken atamas\u0131. <code>?=</code> De\u011fi\u015fken \u00f6nceden tan\u0131mlanmam\u0131\u015fsa de\u011fer atar. <code>:=</code> An\u0131nda de\u011ferlendirme (immediate evaluation). <code>$@</code> Hedef (target) ismi <code>$&lt;</code> \u0130lk ba\u011f\u0131ml\u0131l\u0131k (prerequisite) <code>$^</code> T\u00fcm ba\u011f\u0131ml\u0131l\u0131klar <code>$?</code> Hedeften daha yeni ba\u011f\u0131ml\u0131l\u0131klar <code>make -s</code> Komutlar\u0131 bast\u0131r\u0131r (sessiz \u00e7al\u0131\u015f\u0131r). <code>make -k</code> Hata al\u0131nsa bile m\u00fcmk\u00fcn oldu\u011funca devam eder. <code>make -i</code> Hatalar\u0131 yoksayarak devam eder. <p>*: Shell tarz\u0131 t\u00fcm dosyalarla e\u015fle\u015fir. \u00d6rn: <code>*.c</code></p> <p>%: Pattern (desen) e\u015fle\u015ftirme i\u00e7in kullan\u0131l\u0131r. \u00d6rn: <code>%.o: %.c</code></p> <pre><code>SRC := $(wildcard *.c)\nOBJ := $(SRC:.c=.o)\n</code></pre> <p>Bu kullan\u0131m t\u00fcm .c dosyalar\u0131n\u0131 .o uzant\u0131l\u0131 versiyonlara \u00e7evirir.</p>"},{"location":"build_tooling/make/#basit-makefile-ornekleri","title":"Basit Makefile \u00d6rnekleri","text":""},{"location":"build_tooling/make/#ornek-1-temel-hedef","title":"\u00d6rnek 1: Temel Hedef","text":"<pre><code>hello:\n    echo \"hello, world\"\n\nall: hello\n    echo \"hi\"\n</code></pre>"},{"location":"build_tooling/make/#ornek-2-ayn-hedefe-sahip-birden-fazla-blok","title":"\u00d6rnek 2: Ayn\u0131 Hedefe Sahip Birden Fazla Blok","text":"<p>Not</p> <p>blah hedefi ilk kez \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda komutlar \u00e7al\u0131\u015f\u0131r ve dosya olu\u015fturulursa, tekrar make \u00e7al\u0131\u015ft\u0131r\u0131ld\u0131\u011f\u0131nda blah is up to date mesaj\u0131 al\u0131n\u0131r. Bu durumda dosyada de\u011fi\u015fiklik yap\u0131lmad\u0131k\u00e7a hedef yeniden derlenmez.</p> <pre><code>blah::\n    echo \"hello\"\n\nblah::\n    echo \"hello again\"\n</code></pre>"},{"location":"build_tooling/make/#ornek-3-bagmllk-fark","title":"\u00d6rnek 3: Ba\u011f\u0131ml\u0131l\u0131k Fark\u0131","text":"<p>1. Y\u00f6ntem<pre><code>blah:\n    cc blah.c -o blah\n</code></pre> 2. Y\u00f6ntem<pre><code>blah: blah.c\n    cc blah.c -o blah\n</code></pre></p> <p>Not</p> <ol> <li>y\u00f6ntem tercih edilmelidir. B\u00f6ylece sadece blah.c dosyas\u0131 de\u011fi\u015fti\u011finde hedef yeniden derlenir. Bu y\u00f6ntem zamandan ve kaynaklardan tasarruf sa\u011flar.</li> </ol>"},{"location":"build_tooling/make/#degiskenler-ve-otomatik-degiskenler","title":"De\u011fi\u015fkenler ve Otomatik De\u011fi\u015fkenler","text":"Tan\u0131mlama<pre><code>CC = gcc\nCFLAGS = -Wall -O2\nTARGET = my_program\nOBJ = main.o utils.o\n</code></pre>"},{"location":"build_tooling/make/#kapsaml-makefile-ornegi","title":"Kapsaml\u0131 Makefile \u00d6rne\u011fi","text":"<pre><code># De\u011fi\u015fkenler\nCC = gcc\nCFLAGS = -Wall -O2\nTARGET = my_program\nOBJ = main.o utils.o\n\n# Varsay\u0131lan hedef\nall: $(TARGET)\n\n# Hedef dosya\n$(TARGET): $(OBJ)\n    $(CC) $(CFLAGS) -o $@ $^\n\n# .o dosyalar\u0131n\u0131n nas\u0131l \u00fcretilece\u011fi\n%.o: %.c\n    $(CC) $(CFLAGS) -c $&lt; -o $@\n\n# Temizlik\nclean:\n    rm -f $(TARGET) $(OBJ)\n\n# Ger\u00e7ek dosya olmayan hedefler\n.PHONY: all clean\n</code></pre>"},{"location":"build_tooling/make/#wildcard-ve-pattern-matching","title":"wildcard ve pattern matching","text":"<p><code>wildcard</code>, belirli dosya desenlerini e\u015fle\u015ftirip listeleyen bir fonksiyondur. <code>wildcard</code> fonksiyonu mutlaka <code>:=</code> ile birlikte kullan\u0131lmal\u0131d\u0131r. Aksi halde geni\u015fletilmez.</p> <pre><code>thing_right := $(wildcard *.o)\n</code></pre>"},{"location":"build_tooling/menuconfig/","title":"Kconfig ve Menuconfig Kullan\u0131m","text":"<p>Kconfig/Menuconfig, yaz\u0131l\u0131m projelerinde kullan\u0131c\u0131 taraf\u0131ndan ayarlanabilir yap\u0131land\u0131rma se\u00e7enekleri olu\u015fturmak i\u00e7in kullan\u0131lan bir sistemdir. Linux \u00e7ekirde\u011fi ba\u015fta olmak \u00fczere bir\u00e7ok projede yayg\u0131n olarak kullan\u0131l\u0131r.</p>"},{"location":"build_tooling/menuconfig/#temel-komutlar-ve-yaplar","title":"Temel Komutlar ve Yap\u0131lar","text":"<pre><code>mainmenu \"Ana Men\u00fc Ba\u015fl\u0131\u011f\u0131\"\n\ncomment \"Bilgi veya A\u00e7\u0131klama: $(VARIABLE)\"\n\nmenu \"Alt Men\u00fc Ba\u015fl\u0131\u011f\u0131\"\n    config CONFIG_NAME\n        bool \"G\u00f6r\u00fcnecek \u0130sim\"\n        default y\n        help\n            Bu ayar\u0131n ne i\u015fe yarad\u0131\u011f\u0131n\u0131 a\u00e7\u0131klar.\nendmenu\n</code></pre>"},{"location":"build_tooling/menuconfig/#temel-elemanlar","title":"Temel Elemanlar","text":"<ul> <li><code>mainmenu</code>: Ana ba\u015fl\u0131\u011f\u0131 belirler.</li> <li><code>comment</code>: Bilgilendirme amac\u0131yla kullan\u0131l\u0131r.</li> <li><code>menu / endmenu</code>: Alt men\u00fc olu\u015fturur.</li> <li><code>choice / endchoice</code>: Kullan\u0131c\u0131ya se\u00e7im grubu olu\u015fturur.</li> </ul>"},{"location":"build_tooling/menuconfig/#degisken-turleri-config","title":"De\u011fi\u015fken T\u00fcrleri (config)","text":"<ul> <li><code>bool</code>: A\u00e7\u0131k veya kapal\u0131 (y/n)</li> <li><code>tristate</code>: \u00dc\u00e7 se\u00e7enekli; kapal\u0131 (n), a\u00e7\u0131k (y) veya mod\u00fcl (m)</li> <li><code>string</code>: Metin verisi</li> <li><code>int</code>: Tam say\u0131</li> <li><code>hex</code>: Hexadecimal say\u0131</li> </ul>"},{"location":"build_tooling/menuconfig/#ornek-yaplar","title":"\u00d6rnek Yap\u0131lar","text":"<pre><code>menu \"Toolchain\"\n\n    choice\n        prompt \"Platform\"\n        default PLATFORM_NUTTX\n\n        config PLATFORM_NUTTX\n            bool \"nuttx\"\n\n        config PLATFORM_POSIX\n            bool \"posix\"\n    endchoice\n\n    config USER_NAME\n        string \"Username\"\n        default \"serkan\"\n        help\n            Enter your username.\n\n    config USER_AGE\n        int \"User Age\"\n        default 5\n        range 1 8\n        help\n            Enter your age (1-8).\n\n    config BOARD_PLATFORM\n        string\n        default \"nuttx\" if PLATFORM_NUTTX\n        default \"posix\" if PLATFORM_POSIX\n\n    config CLOCK_PLL_N\n        int \"PLL Clock\"\n        depends on USE_CLOCK_PLL\n        default 20\n        range 8 86\n\nendmenu\n</code></pre>"},{"location":"build_tooling/menuconfig/#sartl-menuler-ve-secimler","title":"\u015eartl\u0131 Men\u00fcler ve Se\u00e7imler","text":"<p>Men\u00fclerin ve se\u00e7eneklerin g\u00f6r\u00fcn\u00fcrl\u00fc\u011f\u00fc ko\u015fullara ba\u011fl\u0131 olabilir.</p> <pre><code>menu \"Drivers\"\n    depends on PLATFORM_QURT || PLATFORM_POSIX\n    source \"src/Kconfig\"\nendmenu\n</code></pre>"},{"location":"build_tooling/menuconfig/#secime-bagl-otomatik-aktiflestirme-select","title":"Se\u00e7ime Ba\u011fl\u0131 Otomatik Aktifle\u015ftirme (select)","text":"<p>Bir yap\u0131land\u0131rma se\u00e7ene\u011fi se\u00e7ildi\u011finde ba\u015fka se\u00e7enekleri otomatik olarak etkinle\u015ftirmek i\u00e7in kullan\u0131l\u0131r. <pre><code>config MODULE_PERIPH_ADC\n    bool \"ADC peripheral driver\"\n    depends on PLATFORM_NUTTX\n    select MODULE_PERIPH_COMMON\n</code></pre></p> <ul> <li><code>tristate</code> tipinde yap\u0131land\u0131rmalar \u00fc\u00e7 duruma sahiptir:<ul> <li>n: Kapat\u0131lm\u0131\u015f (se\u00e7im yok)</li> <li>y: Sabit olarak a\u00e7\u0131k</li> <li>m: Mod\u00fcl olarak derlenir, \u00e7al\u0131\u015fma zaman\u0131nda y\u00fcklenebilir veya kald\u0131r\u0131labilir.</li> </ul> </li> </ul> <pre><code>menu \"Advanced Features\"\n\n    choice\n        tristate \"Enable advanced features\"\n\n        config ADV_FEATURE_1\n            tristate \"Feature 1\"\n\n        config ADV_FEATURE_2\n            tristate \"Feature 2\"\n\n        if ADV_FEATURE_2\n            choice\n                tristate \"Sub Features\"\n\n                config SUB_FEATURE_1\n                    tristate \"Sub Feature 1\"\n\n                config SUB_FEATURE_2\n                    tristate \"Sub Feature 2\"\n            endchoice\n        endif\n    endchoice\nendmenu\n</code></pre>"},{"location":"build_tooling/menuconfig/#komutlar-hakknda-ksa-bilgiler","title":"Komutlar Hakk\u0131nda K\u0131sa Bilgiler","text":"Komut Anlam\u0131 <code>mainmenu</code> Men\u00fc ana ba\u015fl\u0131\u011f\u0131n\u0131 olu\u015fturur. <code>menu/endmenu</code> Men\u00fc olu\u015fturur ve sonland\u0131r\u0131r. <code>choice/endchoice</code> Se\u00e7im gruplar\u0131 olu\u015fturur. <code>config</code> Yap\u0131land\u0131rma se\u00e7eneklerini tan\u0131mlar. <code>default</code> Varsay\u0131lan de\u011feri belirler. <code>depends on</code> \u015earta ba\u011fl\u0131 g\u00f6r\u00fcn\u00fcrl\u00fck sa\u011flar. <code>select</code> Se\u00e7enekleri otomatik etkinle\u015ftirir. <code>range</code> Say\u0131sal de\u011fer aral\u0131\u011f\u0131n\u0131 s\u0131n\u0131rlar. <code>help</code> Kullan\u0131c\u0131ya a\u00e7\u0131klama sunar."},{"location":"build_tooling/menuconfig/#kullanm-tavsiyeleri","title":"Kullan\u0131m Tavsiyeleri","text":"<ul> <li>Yap\u0131land\u0131rma se\u00e7eneklerini anlaml\u0131 ve a\u00e7\u0131klay\u0131c\u0131 isimlerle belirtin.</li> <li><code>help</code> k\u0131s\u0131mlar\u0131n\u0131 a\u00e7\u0131klay\u0131c\u0131 yaz\u0131n.</li> <li>Men\u00fcleri mant\u0131kl\u0131 ve kullan\u0131c\u0131 dostu bir hiyerar\u015fide tutun.</li> <li>\u015earta ba\u011fl\u0131 g\u00f6r\u00fcnebilirlik ile karma\u015f\u0131kl\u0131\u011f\u0131 azalt\u0131n.</li> </ul> <p>Bu rehber, Kconfig ve Menuconfig dosyalar\u0131n\u0131 etkili kullanman\u0131z i\u00e7in temel ve ileri d\u00fczey bilgileri i\u00e7erir.</p>"},{"location":"programming/c/","title":"C Programlama","text":"<ul> <li>LValue: Adrese sahip, atama yap\u0131labilen ifadelerdir.</li> <li>RValue: Atama yap\u0131lamayan, genellikle ge\u00e7ici de\u011ferlerdir.</li> <li>Call by Reference: C dilinde do\u011frudan yoktur, ancak pointerlar arac\u0131l\u0131\u011f\u0131yla benzer i\u015flev sa\u011flanabilir.</li> <li>Call by Value: Parametrelerin fonksiyona kopyalanarak g\u00f6nderilmesidir.</li> <li>Postfix (i++): \u0130\u015flemden sonra art\u0131r\u0131r.</li> <li>Prefix (++i): \u0130\u015flemden \u00f6nce art\u0131r\u0131r.</li> <li>Recursion: Bir fonksiyonun kendisini \u00e7a\u011f\u0131rma i\u015flemidir.</li> <li>Redeclaration: Ayn\u0131 kapsamda ayn\u0131 isimle de\u011fi\u015fken ya da fonksiyon tekrar tan\u0131mlanamaz. Bu hata \u00fcretir.</li> <li><code>,</code> operat\u00f6r\u00fc ayn\u0131 kapsamda ayn\u0131 isimle de\u011fi\u015fken ya da fonksiyon tekrar tan\u0131mlanamaz. Bu hata \u00fcretir.</li> <li>argc: Argument count (arg\u00fcman say\u0131s\u0131)</li> <li>argv: Argument vector (arg\u00fcman dizisi)</li> <li>Diziler bellek adreslerini tutar.</li> <li>dizi[index] ile index[dizi] ayn\u0131 anlama gelir (<code>*(dizi + index)</code>).</li> <li>Temel T\u00fcrler: int, float, double, char, void</li> <li>const: De\u011fi\u015fkeni sabit yapar.</li> <li>sizeof: Veri veya de\u011fi\u015fken boyutunu d\u00f6ner.</li> <li>Struct: Farkl\u0131 veri t\u00fcrlerini gruplar.</li> <li>Bitfield: Haf\u0131zay\u0131 daha verimli kullanmak i\u00e7in bit seviyesinde alan tan\u0131mlar.</li> <li>Enum: Sabitlere anlaml\u0131 isimler verir.</li> <li>Union: Ayn\u0131 bellek b\u00f6lgesini farkl\u0131 veri t\u00fcrleriyle kullan\u0131r.</li> </ul> <pre><code>typedef int tamsayi;\ntamsayi value = 0;\n\nstruct Person {\n  char name[20];\n  int age;\n};\n\ntypedef struct {\n  unsigned int month : 4;\n  unsigned int year : 11;\n  unsigned int day : 5;\n} Date;\n\ntypedef struct {\n  uint8_t x;\n  uint16_t y;\n} __attribute__((packed)) State_s;\n</code></pre> <ul> <li>Snake Case: my_variable_name</li> <li>Camel Case: myVariableName</li> <li>Pascal Case: MyVariableName</li> <li>attribute: Yap\u0131lar\u0131n bellekteki bo\u015fluklar\u0131n\u0131 optimize eder.</li> <li>volatile: Optimize edilmemesi gereken de\u011fi\u015fkenlerde kullan\u0131l\u0131r.</li> </ul> <pre><code>// constructor int main \u00f6nce \u00e7al\u0131\u015fmas\u0131n\u0131 sa\u011flar.\n// destructor int mainden sonra \u00e7a\u0131lmas\u0131n\u0131 sa\u011flar.\n\nvoid __attribute__((constructor)) calledFirst();\nvoid __attribute__((destructor)) calledLast();\n\nvoid main() { printf(\"main\"); }\n\nvoid calledFirst() {  printf(\"constructor\\n\"); }\nvoid calledLast(){ printf(\"destructor\\n\"); }\n\n// packed bellekte olan bo\u015fluklar\u0131n doldurulmas\u0131n\u0131 sa\u011flar. normalde alta bulunan \n// struct  32 byte olur fakat packed  sayesinde 24 byte olur.\ntypedef struct {\n  uint8_t x;\n  uint16_t y;\n} __attribute__((packed)) State_s;\n\nState_s state_1\nState_s state_2 = {1 ,2};\nState_s state_3 = {0}; // B\u00fct\u00fcn verilere 0 atar.\nState_s state_ptr;\nstate_ptr-&gt;x = 10; // ya da *(state_ptr).x = 10;\n</code></pre> <ul> <li>Implicit: Otomatik t\u00fcr d\u00f6n\u00fc\u015f\u00fcm.</li> <li>Explicit: Manuel t\u00fcr d\u00f6n\u00fc\u015f\u00fcm.</li> </ul> <pre><code>int x = (int)3.14; // C tarz\u0131\nint y = static_cast&lt;int&gt;(3.14); // C++ tarz\u0131\n</code></pre> <ul> <li>Ko\u015fullar: if, else if, else, switch</li> <li>D\u00f6ng\u00fcler: for, while, do-while</li> <li>Fonksiyonlar: Void d\u0131\u015f\u0131ndaki fonksiyonlar mutlaka d\u00f6n\u00fc\u015f yapmal\u0131d\u0131r.</li> <li>Define ve Makrolar: Derleme zaman\u0131nda sembolik isimler yarat\u0131r. <code>#define</code> sembolik isimler atanmas\u0131 i\u00e7in kullan\u0131l\u0131r. De\u011fi\u015fkenlerin \u00f6n\u00fcne bo\u015f bir #define koyarak, o de\u011fi\u015fkenin kullan\u0131m amac\u0131 hakk\u0131nda bilgi verilebilir. #define bellek k\u0131sm\u0131nda alan tutmaz derleme s\u0131ras\u0131nda otomatik olarak d\u00fczeltilir.</li> </ul> <pre><code>#define MAX_SIZE 100\n#define __MUTLAK_SONUC__    //bo\u015f define \nint __MUTLAK_SONUC__ degisken;\n</code></pre> <ul> <li>String (Karakter Dizileri): C dilinde, string (karakter dizileri) asl\u0131nda karakterlerden olu\u015fan dizilerdir. Karakter dizileri her zaman \u00f6zel bir sonland\u0131r\u0131c\u0131 karakter <code>\\0</code> (null terminat\u00f6r) ile biter. Bu sonland\u0131r\u0131c\u0131, dizinin sonunu belirtmek i\u00e7in kullan\u0131l\u0131r.<ul> <li>\u00d6rne\u011fin, 6 karakterlik bir metin i\u00e7in bellekte 7 byte'l\u0131k alan ayr\u0131l\u0131r (6 karakter + 1 null terminat\u00f6r).</li> <li>\u00c7ift t\u0131rnak \" i\u00e7inde yaz\u0131lan stringlere otomatik olarak <code>\\0</code> eklenir. Ancak tek t\u0131rnak ' ile belirtilen karakter dizilerinde son karakter olarak manuel <code>\\0</code> eklenmelidir.</li> </ul> </li> </ul> <pre><code>char str1[] = \"Hello\"; // Otomatik olarak \\0 eklenir.\nchar str2[] = {'H', 'i', '\\0'}; // Manuel olarak \\0 eklenm\n</code></pre> <pre><code>#include &lt;stdarg.h&gt;\n\nif(printf(\"Hello World\")) {}  // Bir kez \u00e7al\u0131\u015f\u0131r.\nwhile(printf(\"Hello World\")) {} // Sonsuz d\u00f6ng\u00fc.\n\nfor(int a = 0, b = 10; a &lt; 10 &amp;&amp; b &gt; 2; a++, b--);\nunsigned log int = size_t;\n\nint array[5] = {[0 ... 4] = 5}; // Derleyiciye g\u00f6re kabul edilir.\n\n\nprintf(\"%2.3f\", num);   // Sa\u011f hizal\u0131\nprintf(\"%-2.3f\", num);  // Sol hizal\u0131\nprintf(\"%+2.3f\", num);  // Pozitif say\u0131 \u00f6n\u00fcne '+' koyar\nprintf(\"%05x\", num);    // Bo\u015fluklara 0 koyar\nprintf(\"%*.*f\", 2,3,number); // '*' verilerin d\u0131\u015fardan doldurulmas\u0131n\u0131 sa\u011flar.\nprintf(\"%#x\", number);       // '#' say\u0131lar\u0131n 0x \u015feklinde yaz\u0131lmas\u0131n\u0131 sa\u011flar.\n\nchar buf[100];\nsprintf(buf, \"Say\u0131: %d\", num);\nsscanf(buf, \"Say\u0131: %d\", &amp;num);\n</code></pre> <ul> <li><code>for(;;), while(true)</code> sonsuz d\u00f6ng\u00fcye \u00f6rnektir.</li> <li><code>continue</code> d\u00f6ng\u00fcy\u00fc ba\u015fa al\u0131r. <code>break</code> d\u00f6ng\u00fcden \u00e7\u0131kar. <code>return</code> fonksiyondan \u00e7\u0131kar.</li> <li>Modern derleyiciler de <code>#pragma once</code> kullan\u0131labilir. </li> </ul> <p><pre><code>// HEADER GUARDS\n#ifndef SOME_UNIQUE_NAME_HERE\n#define SOME_UNIQUE_NAME_HERE\n#endif\n</code></pre> <pre><code>int add(int a, int b); // prototip (declaration)\n\nint add(int a, int b) { return a + b; }  // Definition\n\nint sum(int num, ...) { // de\u011fi\u015fken say\u0131da parametre alan fonksiyon\n    int total = 0;\n    va_list args;\n    va_start(args, num);\n    for (int i = 0; i &lt; num; i++) {\n        total += va_arg(args, int);\n    }\n    va_end(args);\n    return total;\n}\n</code></pre></p> <ul> <li>Direct Acces: Bir de\u011fi\u015fkenin ad\u0131n\u0131 kullanarak eri\u015fmektedir.</li> <li>Indirect Access(Dolayl\u0131 Eri\u015fim): Pointer adresinden de\u011fi\u015fken eri\u015fimidir.</li> <li>Genel ama\u00e7lar i\u00e7in <code>void</code> veri tipi kullan\u0131l\u0131r. B\u00fct\u00fcn veri tipleri atamas\u0131 yap\u0131labilir.</li> </ul>"},{"location":"programming/c/#pointer","title":"Pointer","text":"<ul> <li>Bir bellek adresini tutar ve y\u00f6netir.</li> <li>Pointer adresini (ptr), i\u015faret edilen de\u011feri (*ptr) ifade eder. <pre><code>int val = 10;\nint *ptr = &amp;val;\n</code></pre></li> </ul>"},{"location":"programming/c/#dinamik-bellek-yonetimi","title":"Dinamik Bellek Y\u00f6netimi","text":"<ul> <li>malloc: Bellekte belirtilen boyut kadar yer ay\u0131r\u0131r.</li> <li>calloc: Bellekte yer ay\u0131r\u0131r ve temizler.</li> <li>realloc: Daha \u00f6nce ayr\u0131lan bellek alan\u0131n\u0131 yeniden boyutland\u0131r\u0131r.</li> <li>free: Ayr\u0131lan belle\u011fi serbest b\u0131rak\u0131r.</li> </ul> <pre><code>int *arr = (int*)malloc(sizeof(int)*10);\nfree(arr);\n</code></pre>"},{"location":"programming/c/#temel-veri-yaplar","title":"Temel Veri Yap\u0131lar\u0131","text":"<ul> <li>Stack: Program derlenirken sabit boyutludur, LIFO mant\u0131\u011f\u0131 kullan\u0131r.</li> <li>Heap: \u00c7al\u0131\u015fma zaman\u0131 s\u0131ras\u0131nda dinamik bellek y\u00f6netimine izin verir.</li> <li>Linked List (Ba\u011fl\u0131 Liste): Veri par\u00e7alar\u0131n\u0131 birbirine ba\u011flayan pointerlarla dinamik haf\u0131za y\u00f6netimi sa\u011flar.</li> </ul>"},{"location":"programming/cpp/","title":"C++ Programlama","text":"<ul> <li>Bir de\u011fi\u015fkeni ba\u015flatman\u0131n (initialization) \u00fc\u00e7 yolu vard\u0131r:<ul> <li>Copy initialization (\u00f6rne\u011fin <code>int a = 5;</code>)</li> <li>Direct initialization (\u00f6rne\u011fin <code>int b(5);</code>)</li> <li>List initialization (\u00f6rne\u011fin <code>int c{5};</code>)</li> </ul> </li> </ul> <p>Not</p> <p>En g\u00fcvenilir olan\u0131 list initialization\u2019d\u0131r; \u00e7\u00fcnk\u00fc daralt\u0131c\u0131 (narrowing) d\u00f6n\u00fc\u015f\u00fcmlere \u00f6rne\u011fin bir float de\u011feri do\u011frudan int\u2019e izin vermez.</p> <ul> <li> <p>Tan\u0131mlan\u0131p hi\u00e7 kullan\u0131lmayan de\u011fi\u015fkenler i\u00e7in derleyici uyar\u0131 verir. Bu uyar\u0131y\u0131 bast\u0131rmak i\u00e7in C++17\u2019den itibaren <code>[[maybe_unused]]</code> \u00f6zniteli\u011fini kullanabiliriz.</p> </li> <li> <p><code>::</code> operat\u00f6r\u00fc, \u00f6n\u00fcnde bir isim (\u00f6rne\u011fin bir namespace veya s\u0131n\u0131f ad\u0131) yoksa \u201cglobal\u201d ad alan\u0131n\u0131 ifade eder.</p> </li> </ul> <pre><code>#include &lt;iostream&gt;   // Standart giri\u015f-\u00e7\u0131k\u0131\u015f k\u00fct\u00fcphanesi\n\nusing namespace std; // T\u00fcm std isimlerini do\u011frudan kullanmam\u0131za izin verir\n// Sadece belli bir \u00f6geyi dahil etmek istersek:\n// using std::cout;\n\nint main() {\n    [[maybe_unused]] int a = 5; // copy initialization\n    int b(5);                   // direct initialization\n    int c{5};                   // list initialization \u2014 narrowing\u2019a izin vermez\n}\n</code></pre> <ul> <li> <p><code>std::cin &gt;&gt;</code> operat\u00f6r\u00fc bo\u015fluk karakterine kadar okurken,</p> </li> <li> <p><code>std::getline(cin, str)</code> sat\u0131r sonuna (veya belirledi\u011finiz ba\u015fka bir s\u0131n\u0131rlay\u0131c\u0131ya) kadar t\u00fcm girdi sat\u0131r\u0131n\u0131 al\u0131r. Bu sayede kullan\u0131c\u0131dan bo\u015fluk i\u00e7eren sat\u0131rlar veya t\u00fcm sat\u0131r\u0131 almam\u0131z gerekti\u011finde getline tercih edilir.</p> </li> <li> <p><code>namespace</code>, ayn\u0131 isimli tan\u0131mlamalar\u0131n \u00e7ak\u0131\u015fmas\u0131n\u0131 \u00f6nlemek i\u00e7in kullan\u0131l\u0131r.</p> <ul> <li>Hem de\u011fi\u015fken, hem fonksiyon, hem de s\u0131n\u0131f ve di\u011fer tan\u0131mlar\u0131 ayr\u0131 gruplarda toplayabiliriz.</li> <li>\u0130\u00e7 i\u00e7e namespace\u2019ler tan\u0131mlamak da m\u00fcmk\u00fcnd\u00fcr.</li> </ul> </li> </ul> <pre><code>namespace A {\n    namespace B {\n        void foo();\n    }\n}\n</code></pre> <ul> <li><code>constexpr</code>, derleme zaman\u0131nda hesaplanabilen ve kesinlikle sabit (compile-time constant) olan de\u011ferler i\u00e7in;</li> <li><code>const</code> ise derlendikten sonra de\u011fi\u015ftirilemeyen, ama derleme zaman\u0131nda mutlaka hesaplanamayabilecek de\u011ferler i\u00e7in kullan\u0131l\u0131r</li> <li>C++20 ile aggregate tipler i\u00e7in \u201cdesignated initializer\u201d deste\u011fi eklendi. B\u00f6ylece yap\u0131daki sadece istedi\u011finiz \u00fcyeyi atayabilirsiniz: <pre><code>struct Foo { int a, b, c; };\n\nFoo f0 {1, 2, 3};                   // T\u00fcm \u00fcyeleri s\u0131rayla atar\nFoo f1 {.a = 1, .c = 3};            // Sadece a ve c\u2019yi atar; b = 0\n// C++20\u2019de \u00fcye s\u0131ras\u0131 \u00f6nemli de\u011fil:\nFoo f2 {.c = 3, .a = 1};            // Ge\u00e7erli\n</code></pre></li> <li><code>typedef</code> Eski C/C++ tarz\u0131 tip takma ad\u0131 (alias) olu\u015fturma.</li> <li> <p><code>using</code> C++11 ile gelen, daha okunur ve \u015fablonlarla da \u00e7al\u0131\u015fabilen modern alias tan\u0131m\u0131. <pre><code>// Eski stil\ntypedef unsigned long long ULLI1;\n\n// Yeni, daha okunur stil\nusing ULLI2 = unsigned long long;\n</code></pre></p> </li> <li> <p>\u00d6ne s\u0131f\u0131r koymak: oktal\u0131k (\u00f6r. 012); ekrana oktal g\u00f6sterimi i\u00e7in std::oct.</p> </li> <li>\u00d6ne 0x koymak: onalt\u0131l\u0131k (\u00f6r. 0x12); ekrana onalt\u0131l\u0131k i\u00e7in std::hex.</li> <li>\u00d6ne 0b koymak: ikilik (\u00f6r. 0b10).</li> <li>C++14+\u2019te b\u00fcy\u00fck say\u0131larda okuryaz\u0131l\u0131\u011f\u0131n\u0131 art\u0131rmak i\u00e7in t\u0131rnak: <code>100'000'000</code>.</li> </ul>"},{"location":"programming/cpp/#donguler-ve-kontrol-yaplar","title":"D\u00f6ng\u00fcler ve Kontrol Yap\u0131lar\u0131","text":"<p>C++\u2019ta klasik kontrol yap\u0131lar\u0131n\u0131n yan\u0131 s\u0131ra range-based for (C++11) d\u00f6ng\u00fcs\u00fc de bulunur.</p> <ul> <li><code>for (init; cond; inc)</code>, <code>while (cond)</code>, <code>do { \u2026 } while (cond);</code></li> <li><code>if (cond) { \u2026 } else { \u2026 }</code></li> <li><code>switch (expr) { case \u2026: \u2026; break; \u2026 }</code></li> <li><code>goto label;</code> (genellikle \u00f6nerilmez; kod ak\u0131\u015f\u0131n\u0131 karma\u015f\u0131kla\u015ft\u0131r\u0131r)</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;string&gt;\nusing namespace std::literals;  \n\nint main() {\n    std::vector words{ \"peter\"s, \"likes\"s, \"frozen\"s };\n    for (auto&amp; word : words) {\n        std::cout &lt;&lt; word &lt;&lt; ' ';\n    }\n    // \u00c7\u0131kt\u0131: peter likes frozen \n}\n</code></pre>"},{"location":"programming/cpp/#program-sonlandrma-ve-hata-denetimi","title":"Program\u0131 Sonland\u0131rma ve Hata Denetimi","text":"<ul> <li><code>std::exit(int status):</code> Program\u0131 \u201cnormal\u201d olarak sonland\u0131r\u0131r.</li> <li><code>std::atexit(func):</code> Program kapan\u0131rken func()\u2019u \u00e7a\u011f\u0131r\u0131r.</li> <li><code>std::abort():</code> Program\u0131 aniden, \u201cabnormal\u201d bi\u00e7imde sonland\u0131r\u0131r.</li> <li><code>assert(cond):</code> cond sa\u011flanmazsa program\u0131 durdurur (yaln\u0131zca NDEBUG tan\u0131ml\u0131 de\u011filken).</li> </ul>"},{"location":"programming/cpp/#fonksiyonlar-ve-inline-namespace","title":"Fonksiyonlar ve Inline Namespace","text":"<ul> <li>inline fonksiyon: Derleme a\u015famas\u0131nda \u00e7a\u011fr\u0131ld\u0131\u011f\u0131 yere yerle\u015ftirilir (inlining), fonksiyon \u00e7a\u011fr\u0131s\u0131 y\u00fck\u00fcn\u00fc azalt\u0131r.</li> <li>inline namespace: Birden fazla s\u00fcr\u00fcm i\u00e7eren k\u00fct\u00fcphanelerde, \u00f6ntan\u0131ml\u0131 s\u00fcr\u00fcm\u00fc belirtmek i\u00e7in:</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nnamespace V1 {\n    void doSomething() { std::cout &lt;&lt; \"V1\\n\"; }\n}\n\ninline namespace V2 {\n    void doSomething() { std::cout &lt;&lt; \"V2\\n\"; }\n}\n\nint main() {\n    V1::doSomething(); // V1\n    V2::doSomething(); // V2\n    doSomething();     // inline namespace \u2192 V2\n}\n</code></pre> <ul> <li>constexpr vs. consteval vs. constexpr<ul> <li>constexpr: Derleme zaman\u0131nda hesaplanabilir, fakat ihtiya\u00e7 duyuldu\u011funda \u00e7al\u0131\u015fma zaman\u0131nda da \u00e7a\u011fr\u0131labilir.</li> <li>consteval: Her \u00e7a\u011fr\u0131s\u0131 derleme zaman\u0131nda kesinlikle de\u011ferlendirilir (C++20).</li> </ul> </li> </ul>"},{"location":"programming/cpp/#lambda-ifadeleri","title":"Lambda \u0130fadeleri","text":"<ul> <li>Anonim fonksiyon tan\u0131m\u0131 yapar: <pre><code>auto f = []() { std::cout &lt;&lt; \"Hello\\n\"; };\nf();\n</code></pre></li> <li>Parametre ve d\u00f6n\u00fc\u015f: <pre><code>auto div = [](int x, int y, bool intDiv) -&gt; double {\n    if (intDiv)\n        return x / y;                   // int b\u00f6lme, sonra double\u2019a d\u00f6n\u00fc\u015ft\u00fcr\u00fcl\u00fcr\n    else\n        return static_cast&lt;double&gt;(x) / y;\n};\n</code></pre></li> <li>Yakalama listesi<ul> <li><code>[=]</code> t\u00fcm yerel de\u011fi\u015fkenleri de\u011fer ile kopyalar</li> <li><code>[&amp;]</code> t\u00fcm yerel de\u011fi\u015fkenlere referans verir</li> <li><code>[a, &amp;b]</code> belli de\u011fi\u015fkeni de\u011fer, di\u011ferini referans al\u0131r</li> <li>mutable ile de\u011fer yakalansa bile i\u00e7erde de\u011fi\u015ftirme izinli olur ama d\u0131\u015far\u0131 etkilemez</li> </ul> </li> </ul> <pre><code>int a = 1, b = 2;\nauto lv = [=]() mutable { a = 5; return a; }; // d\u0131\u015far\u0131daki a de\u011fi\u015fmez\nauto lf = [&amp;]()         { b = 5; return b; }; // d\u0131\u015far\u0131daki b de\u011fi\u015fir\n</code></pre>"},{"location":"programming/cpp/#sablonlar-templates","title":"\u015eablonlar (Templates)","text":"<ul> <li>C++\u2019ta t\u00fcrden ba\u011f\u0131ms\u0131z kod yazmak i\u00e7in kullan\u0131l\u0131r.</li> <li>E\u011fer t\u00fcm arg\u00fcmanlar ayn\u0131 t\u00fcrden ise &lt; &gt; yazmaya gerek yoktur.</li> <li>Farkl\u0131 t\u00fcrler i\u00e7in genellikle t\u00fcrleri kendiniz belirtirsiniz. <pre><code>#include &lt;iostream&gt;\ntemplate&lt;typename T, typename U&gt;\nauto add(T a, U b) {\n    return a + b;\n}\n\nint main() {\n    std::cout &lt;&lt; add(10, 3.5) &lt;&lt; '\\n';    // 13.5\n    std::cout &lt;&lt; add&lt;int, double&gt;(10, 3.5) &lt;&lt; '\\n'; // a\u00e7\u0131k belirtilmi\u015f\n}\n</code></pre></li> <li>S\u0131n\u0131f \u015eablonlar\u0131 ve Varsay\u0131lan Arg\u00fcman <pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;typename T, typename U = int&gt;\nclass MyClass {\npublic:\n    MyClass() {\n        T value{};\n        std::cout &lt;&lt; typeid(value).name() &lt;&lt; '\\n';\n    }\n    template&lt;typename X&gt;\n    void add(X a, X b) {\n        std::cout &lt;&lt; (a + b) &lt;&lt; '\\n';\n    }\n};\n\nint main() {\n    MyClass&lt;double&gt;    m1;    // U = int\n    MyClass&lt;char, long&gt; m2;   // a\u00e7\u0131k belirtildi\n    m1.add(1.2, 3.4);\n    m1.add&lt;double&gt;(5.5, 6.6);\n}\n</code></pre></li> </ul>"},{"location":"programming/cpp/#bitset","title":"Bitset","text":"<pre><code>#include &lt;bitset&gt;\nbitset&lt;5&gt; bits;    // 5 bitlik bir dizi\ncout &lt;&lt; bits &lt;&lt; endl;  // 00000\nbits = 10;\ncout &lt;&lt; bits &lt;&lt; endl;  // 01010\n</code></pre>"},{"location":"programming/cpp/#dinamik-bellek","title":"Dinamik Bellek","text":"<pre><code>char* buffer = new char[8];   // Bellekten dizi ay\u0131rma\ndelete[] buffer;              // Dizi silme\n\nconst int* ptr1; // \u0130\u015faret etti\u011fi de\u011fer sabit, adres de\u011fi\u015febilir\nint* const ptr2; // Adres sabit, i\u015faret etti\u011fi de\u011fer de\u011fi\u015febilir\n\nint (*array)[5] = new int[x][5];  // x\u00d75\u2019lik matris\n</code></pre>"},{"location":"programming/cpp/#smart-pointers","title":"Smart Pointers","text":"<p>C++\u2019ta ham i\u015faret\u00e7iler (new/delete) yerine ak\u0131ll\u0131 i\u015faret\u00e7iler (smart pointers) kullanmak, bellek s\u0131z\u0131nt\u0131lar\u0131n\u0131 ve \u00e7ifte silme hatalar\u0131n\u0131 b\u00fcy\u00fck oranda ortadan kald\u0131r\u0131r. \u00dc\u00e7 ana t\u00fcr\u00fc vard\u0131r: 1. <code>std::unique_ptr&lt;T&gt;</code> Tek sahipli ak\u0131ll\u0131 i\u015faret\u00e7idir. Sahip oldu\u011fu nesnenin bellekten silinmesini otomatikle\u015ftirir: unique_ptr kapsam (scope) sonland\u0131\u011f\u0131nda delete \u00e7a\u011fr\u0131l\u0131r. Kopyalanamaz, ancak ta\u015f\u0131nabilir (std::move ile). Bu sayede \u00e7ifte silme riskini ve bellek s\u0131z\u0131nt\u0131lar\u0131n\u0131 \u00f6nler. \u0130sterseniz \u00f6zel bir silici (deleter) de tan\u0131mlayabilirsiniz:</p> <pre><code>auto fileCloser = [](FILE* f){ if(f) fclose(f); };\nstd::unique_ptr&lt;FILE, decltype(fileCloser)&gt; fptr(fopen(\"log.txt\",\"r\"), fileCloser);\n</code></pre> <ol> <li> <p><code>std::shared_ptr&lt;T&gt;</code> Payla\u015f\u0131ml\u0131 sahiplik sa\u011flayan i\u015faret\u00e7idir. Ayn\u0131 nesneye birden fazla shared_ptr i\u015faret edebilir ve referans say\u0131s\u0131 (use_count) s\u0131f\u0131rlanana dek nesne silinmez. D\u00f6ng\u00fcsel ba\u011f\u0131ml\u0131l\u0131k riskini k\u0131rmak i\u00e7in std::weak_ptr kullanarak \u201czay\u0131f\u201d i\u015faret\u00e7i olu\u015fturabilirsiniz. Referans say\u0131s\u0131n\u0131 y\u00f6netmek i\u00e7in atomik i\u015flemler kulland\u0131\u011f\u0131ndan, unique_ptr\u2019a g\u00f6re biraz daha maliyetlidir.</p> </li> <li> <p><code>std::make_unique&lt;T&gt;(...)</code> ve <code>std::make_shared&lt;T&gt;(...)</code> C++14/17 ile gelen fabrikalar (factory functions). Ham i\u015faret\u00e7i yerine do\u011frudan ak\u0131ll\u0131 i\u015faret\u00e7i olu\u015fturur ve exception safety (istisna g\u00fcvenli\u011fi) sa\u011flar:</p> </li> </ol> <pre><code>auto up = std::make_unique&lt;MyClass&gt;(ctorArg1, ctorArg2);\nauto sp = std::make_shared&lt;MyClass&gt;(ctorArg1, ctorArg2);\n</code></pre> <ul> <li>make_unique: yaln\u0131zca bir sahipli unique_ptr d\u00f6nd\u00fcr\u00fcr.</li> <li>make_shared: nesneyi ve referans sayac\u0131 tek bir bellek blo\u011funda tutar, daha verimli bellek kullan\u0131m\u0131 sunar.</li> </ul>"},{"location":"programming/cpp/#casting-turleri","title":"Casting T\u00fcrleri","text":"<ol> <li>static_cast(x): Derleme zaman\u0131nda g\u00fcvenli d\u00f6n\u00fc\u015f\u00fcmler (\u00f6rne\u011fin say\u0131 t\u00fcrleri aras\u0131). <li>dynamic_cast(p): \u00c7al\u0131\u015fma zaman\u0131nda polimorfik s\u0131n\u0131flar aras\u0131nda g\u00fcvenli downcast/upcast. <li>const_cast(x): const niteli\u011fini kald\u0131rmak i\u00e7in. <li>reinterpret_cast(p): \u0130ki i\u015f par\u00e7ac\u0131\u011f\u0131 aras\u0131ndaki bellek g\u00f6sterimini yeniden yorumlamak i\u00e7in (\u00e7ok dikkatli kullan\u0131lmal\u0131). <pre><code>float  f   = 3.14f;\nint    i1  = static_cast&lt;int&gt;(f);\n\nclass Base { virtual void foo() {} };\nclass Derived : public Base {};\n\nBase*       bp = new Derived();\nDerived*    dp = dynamic_cast&lt;Derived*&gt;(bp);\n\nconst int   x  = 5;\nint&amp;        y  = const_cast&lt;int&amp;&gt;(x);\n\nint*        p  = reinterpret_cast&lt;int*&gt;(0x1234);\n</code></pre>"},{"location":"programming/cpp/#stdvector-vs-stdarray","title":"<code>std::vector</code> vs. <code>std::array</code>","text":"<p>C++\u2019ta dinamik ve sabit boyutlu diziler i\u00e7in iki temel s\u0131n\u0131f \u015fablonu vard\u0131r:</p> <ul> <li><code>std::vector&lt;T&gt;</code><ul> <li>Dinamik boyutlu dizi. Eleman ekledik\u00e7e otomatik b\u00fcy\u00fcr.</li> <li>Rastgele eri\u015fim i\u00e7in <code>operator[]</code> ve s\u0131n\u0131r denetimli <code>at()</code> sa\u011flar.</li> <li><code>vec[i]</code> h\u0131zl\u0131 ama s\u0131n\u0131r denetimsiz.</li> <li><code>vec.at(i)</code> s\u0131n\u0131r d\u0131\u015f\u0131 eri\u015fimde std::out_of_range f\u0131rlat\u0131r.</li> </ul> </li> </ul> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; primes{2, 3, 5, 7};  // Ba\u015flang\u0131\u00e7 listesiyle 4 eleman\n    std::vector&lt;int&gt; data(10);            // 10 elemanl\u0131, t\u00fcm de\u011ferler 0\n\n    // Hatal\u0131: do\u011frudan tek say\u0131yla vekt\u00f6r olu\u015fturulamaz\n    // std::vector&lt;int&gt; v1 = 10;  \n\n    // Do\u011fru: tek elemanl\u0131 vekt\u00f6r\n    std::vector&lt;int&gt; v1{10};\n\n    // Eri\u015fim\n    std::cout &lt;&lt; primes[1] &lt;&lt; \"\\n\";       // 3\n    std::cout &lt;&lt; v1.at(0) &lt;&lt; \"\\n\";        // 10\n\n    // Boyut \u00f6\u011frenme\n    std::cout &lt;&lt; \"Size: \"     &lt;&lt; v1.size()     &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Capacity: \" &lt;&lt; v1.capacity() &lt;&lt; \"\\n\";\n}\n</code></pre> <ul> <li> <p><code>std::array&lt;T, N&gt;</code></p> <ul> <li>Sabit boyutlu dizi; derleme zaman\u0131nda N belirlenir.</li> <li>\u0130\u00e7inde C stili dizilere benzer \u015fekilde \u00e7al\u0131\u015f\u0131r, ama STL ile uyumludur.</li> <li><code>size()</code>, <code>at()</code>, <code>operator[]</code>, <code>begin()</code>, <code>end()</code> gibi \u00fcyelere sahiptir. <pre><code>#include &lt;array&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::array&lt;int, 5&gt; arr = {10, 20, 30, 40, 50};\n    for (std::size_t i = 0; i &lt; arr.size(); ++i) {\n        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';\n    }\n    // \u00c7\u0131kt\u0131: 10 20 30 40 50 \n}\n</code></pre></li> </ul> </li> <li> <p><code>empty():</code> Bo\u015fsa true, de\u011filse false d\u00f6ner.</p> </li> <li><code>size():</code> Ge\u00e7erli eleman say\u0131s\u0131n\u0131 d\u00f6ner.</li> <li><code>capacity():</code> Ayr\u0131lm\u0131\u015f bellek kapasitesini d\u00f6ner; size() \u2264 capacity().</li> <li><code>reserve(n):</code> Kapasiteyi en az n olacak \u015fekilde \u00f6nceden ay\u0131r\u0131r; yeniden tahsisi azalt\u0131r.</li> <li><code>resize(n):</code> Boyutu n olarak ayarlar; yeni elemanlar varsay\u0131lan T ctor ile olu\u015fturulur.</li> <li><code>push_back(val):</code> Sonuna bir kopya ekler.</li> <li><code>emplace_back(args\u2026):</code> Nesneyi yerinde (in-place) olu\u015fturur; kopya maliyeti yok.</li> <li><code>pop_back():</code> Son eleman\u0131 siler.</li> <li><code>front() / back():</code> \u0130lk ve son eleman\u0131 referans olarak d\u00f6ner.</li> </ul> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main() {\n    std::vector&lt;int&gt; v;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"Empty? \" &lt;&lt; v.empty() &lt;&lt; \"\\n\";\n\n    v.reserve(5);              // Kapasite \u2265 5\n    for (int i = 1; i &lt;= 5; ++i) {\n        v.emplace_back(i * 10); // 10, 20, 30, 40, 50\n    }\n\n    std::cout &lt;&lt; \"Size: \"     &lt;&lt; v.size()     &lt;&lt; \"\\n\"; // 5\n    std::cout &lt;&lt; \"Capacity: \" &lt;&lt; v.capacity() &lt;&lt; \"\\n\";\n\n    v.resize(3);               // art\u0131k {10,20,30}\n    std::cout &lt;&lt; \"After resize: \";\n    for (auto x : v) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; \"\\n\";\n\n    v.push_back(99);           // {10,20,30,99}\n    std::cout &lt;&lt; \"Last element: \" &lt;&lt; v.back() &lt;&lt; \"\\n\";\n\n    v.pop_back();              // son eleman\u0131 kald\u0131r\u0131r\n    std::cout &lt;&lt; \"After pop: \";\n    for (auto x : v) std::cout &lt;&lt; x &lt;&lt; ' ';\n    std::cout &lt;&lt; \"\\n\";\n}\n</code></pre>"},{"location":"programming/cpp/#nesne-yonelimli-programlama-oop","title":"Nesne Y\u00f6nelimli Programlama (OOP)","text":"<ol> <li> <p>Eri\u015fim Belirleyicileri (Access Specifiers)</p> <ul> <li><code>public</code>: Her yerden eri\u015filebilir.</li> <li><code>protected</code>: Sadece o s\u0131n\u0131f i\u00e7inden ve ondan t\u00fcreyen alt s\u0131n\u0131flardan eri\u015filebilir.</li> <li><code>private</code>: Yaln\u0131zca tan\u0131mland\u0131\u011f\u0131 s\u0131n\u0131f\u0131n i\u00e7inden eri\u015filebilir. (Varsay\u0131lan eri\u015fim seviyesi s\u0131n\u0131f (class) i\u00e7inde private\u2019d\u0131r.) <pre><code>class A {\npublic:\n    void pub();      // her yerden\nprotected:\n    void prot();     // A ve alt s\u0131n\u0131flar\nprivate:\n    void priv();     // sadece A i\u00e7inde\n};\n</code></pre></li> </ul> </li> <li> <p>\u00d6zel \u00dcye Fonksiyonlar: <code>Default</code>, <code>Delete</code>, <code>Special Members</code></p> <ul> <li>C++ derleyici, s\u0131n\u0131f\u0131n\u0131z i\u00e7in e\u011fer belirtmezseniz a\u015fa\u011f\u0131dakileri \u201cdefault\u201d olarak olu\u015fturur:</li> <li>Varsay\u0131lan yap\u0131c\u0131 (default constructor)</li> <li>Y\u0131k\u0131c\u0131 (destructor)</li> <li>Kopya yap\u0131c\u0131 (copy constructor)</li> <li>Atama operat\u00f6r\u00fc (copy assignment operator) <pre><code>class MyClass {\npublic:\n    MyClass(int x) : value(x) {}     // \u00d6zel yap\u0131c\u0131\n    MyClass() = default;             // Derleyici yap\u0131c\u0131y\u0131 olu\u015fturursun\n    MyClass(const MyClass&amp;) = delete;           // Kopyalamay\u0131 yasakla\n    MyClass&amp; operator=(const MyClass&amp;) = delete; // Atamay\u0131 yasakla\n    ~MyClass() = default;            // Varsay\u0131lan y\u0131k\u0131c\u0131\nprivate:\n    int value;\n};\n</code></pre></li> </ul> </li> <li> <p><code>this</code> \u0130\u015faret\u00e7isi ve Ba\u015flat\u0131c\u0131 Listesi</p> <ul> <li><code>this</code>, i\u00e7inde bulundu\u011funuz nesnenin adresini g\u00f6steren i\u015faret\u00e7idir.</li> <li>\u00dcye ba\u015flatma listesi (<code>initializer list</code>) ile, yap\u0131c\u0131 g\u00f6vdesine girmeden \u00f6nce \u00fcye de\u011fi\u015fkenlerinizi atayabilirsiniz; b\u00f6ylece \u00e7ak\u0131\u015fan isimlerde de netlik sa\u011flan\u0131r: <pre><code>class Point {\nint x, y;\npublic:\nPoint(int x, int y) : x(x), y(y) {}  // soldaki x: \u00fcye, sa\u011fdaki: parametre\nPoint() : x(0), y(0) {}              // default yap\u0131c\u0131\n};\n</code></pre></li> </ul> </li> <li> <p>Kaps\u00fclleme (Encapsulation)</p> <ul> <li>S\u0131n\u0131f\u0131n i\u00e7 verilerini private tutup, public getter/ setter metotlar\u0131yla korumal\u0131 eri\u015fim sa\u011flars\u0131n\u0131z: <pre><code>class Rectangle {\nprivate:\n    double width, height;\npublic:\n    void setWidth(double w) { width = w; }\n    double getWidth() const { return width; }\n    // Benzer setter/getter\u2019lar height i\u00e7in de...\n};\n</code></pre></li> </ul> </li> <li> <p>Static \u00dcyeler</p> <ul> <li>static \u00fcye de\u011fi\u015fken ve fonksiyonlar s\u0131n\u0131fa ait, nesneye de\u011fil.</li> <li>static \u00fcye fonksiyonlar sadece ba\u015fka static \u00fcyelere eri\u015febilir.</li> <li>Tan\u0131m\u0131 s\u0131n\u0131f d\u0131\u015f\u0131na bir kez yap\u0131lmal\u0131d\u0131r: <pre><code>class Counter {\npublic:\n    static int count;\n    Counter() { ++count; }\n};\nint Counter::count = 0;  // s\u0131n\u0131f d\u0131\u015f\u0131 tan\u0131m\n\n// Kullan\u0131m:\nCounter a, b;\nstd::cout &lt;&lt; Counter::count;  // 2\n</code></pre></li> </ul> </li> <li> <p>Friend (Arkada\u015f) Bildirimi</p> <ul> <li><code>friend</code> fonksiyon veya s\u0131n\u0131flar, private/protected \u00fcyelere eri\u015febilir: <pre><code>class A {\n    int x = 42;\n    friend void printA(const A&amp;);\n};\n\nvoid printA(const A&amp; a) {\n    std::cout &lt;&lt; a.x &lt;&lt; \"\\n\";  // private x\u2019e eri\u015fim\n}\n</code></pre></li> </ul> </li> <li> <p>Operat\u00f6r A\u015f\u0131r\u0131 Y\u00fckleme (Operator Overloading)</p> <ul> <li>S\u0131n\u0131f\u0131n\u0131zda var olan operat\u00f6rleri \u00f6zelle\u015ftirebilirsiniz; ancak t\u00fcm operat\u00f6rler y\u00fcklenemez (sizeof, ::, .* vb. yasakt\u0131r). <pre><code>class Vec {\n    int x, y;\npublic:\n    Vec(int x, int y) : x(x), y(y) {}\n    Vec operator+(const Vec&amp; r) const { return Vec{x + r.x, y + r.y}; }\n    Vec&amp; operator+=(const Vec&amp; r) { x += r.x; y += r.y; return *this; }\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Vec&amp; v) {\n        return os &lt;&lt; \"(\" &lt;&lt; v.x &lt;&lt; \", \" &lt;&lt; v.y &lt;&lt; \")\";\n    }\n};\n</code></pre></li> </ul> </li> <li> <p><code>const</code> \u00dcyeler ve mutable</p> <ul> <li><code>const</code> \u00fcye fonksiyonlar (void f() const) s\u0131n\u0131f verilerini de\u011fi\u015ftirmez.</li> <li><code>mutable</code> ile i\u015faretlenmi\u015f \u00fcye de\u011fi\u015fkenler, const fonksiyonlar i\u00e7inde bile de\u011fi\u015ftirilebilir: <pre><code>class Example {\n    mutable int cache;\npublic:\n    Example() : cache(0) {}\n    int getCache() const { return cache++; } // derleme hatas\u0131 yok\n};\n</code></pre></li> </ul> </li> <li> <p><code>explicit</code> Yap\u0131c\u0131lar</p> <ul> <li>Tek parametreli yap\u0131c\u0131lar i\u00e7in explicit koyarak istenmeyen otomat d\u00f6n\u00fc\u015f\u00fcmleri \u00f6nlersiniz: <pre><code>class Foo {\npublic:\n    explicit Foo(int x);\n};\n\nvoid bar(Foo f);\n\nbar(10);       // HATA: otomatik d\u00f6n\u00fc\u015f\u00fcm yasak\nbar(Foo(10));  // DO\u011eRU\n</code></pre></li> </ul> </li> <li> <p>Kal\u0131t\u0131m (Inheritance)</p> <ul> <li>Tekli kal\u0131t\u0131m: class Derived : access Base { \u2026 };</li> <li>Eri\u015fim: public, protected veya private (default private). <pre><code>class Base { public: void foo(); };\nclass Derived : public Base { /* Base::foo() kullanabilir */ };\n\nclass A { public: void f(); };\nclass B { public: void g(); };\nclass C : public A, public B { /* hem f() hem g() */ };\n</code></pre></li> <li>Virt\u00fcel kal\u0131t\u0131m (diamond problemini \u00e7\u00f6zer): <pre><code>class Device { /*\u2026*/ };\nclass Scanner : virtual public Device { /*\u2026*/ };\nclass Printer : virtual public Device { /*\u2026*/ };\nclass Copier  : public Scanner, public Printer { /*\u2026*/ };\n</code></pre></li> </ul> </li> <li> <p>Polimorfizm (\u00c7ok Bi\u00e7imlilik)</p> <ul> <li>virtual \u00fcye fonksiyonlar, \u00e7a\u011fr\u0131n\u0131n ger\u00e7ek nesne t\u00fcr\u00fcne g\u00f6re \u00e7\u00f6z\u00fclmesini sa\u011flar. <pre><code>class Base {\npublic:\n    virtual void work() { std::cout&lt;&lt;\"Base\\n\"; }\n    virtual ~Base() = default;  // sanal y\u0131k\u0131c\u0131\n};\n\nclass Derived : public Base {\npublic:\n    void work() override { std::cout&lt;&lt;\"Derived\\n\"; }\n};\n\nint main() {\n    Base* p = new Derived();\n    p-&gt;work();   // \u201cDerived\u201d yazd\u0131r\u0131r\n    delete p;\n}\n</code></pre></li> <li>Saf sanal fonksiyon (pure virtual) ile soyut s\u0131n\u0131f (interface) olu\u015fturabilirsiniz: <pre><code>class IShape {\npublic:\n    virtual double area() const = 0;  // saf sanal\n    virtual ~IShape() = default;\n};\n</code></pre></li> </ul> </li> </ol>"}]}